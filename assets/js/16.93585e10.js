(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{510:function(v,_,t){"use strict";t.r(_);var i=t(25),l=Object(i.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"第三章-js-基础概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三章-js-基础概念"}},[v._v("#")]),v._v(" 第三章 JS 基础概念")]),v._v(" "),t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),t("p",[v._v("本系列是在学习 JS 的过程中所做的读书笔记，将重点知识提取出来在闲暇时刻翻阅，如果你看过这本书，那收藏起来当复习用；如果你没看过这本书，那还犹豫啥，收藏起来抱佛脚用的啦~~~")]),v._v(" "),t("blockquote",[t("p",[v._v("注：内容摘抄或总结自《JavaScript 高级程序设计》第三到七章")])]),v._v(" "),t("h2",{attrs:{id:"一、语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、语法"}},[v._v("#")]),v._v(" 一、语法")]),v._v(" "),t("h3",{attrs:{id:"语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[v._v("#")]),v._v(" 语法")]),v._v(" "),t("ul",[t("li",[v._v("JS 区分大小写")]),v._v(" "),t("li",[v._v("标识符：不能把关键字、保留字、true、false 和 null 用作标识符")]),v._v(" "),t("li",[v._v("注释：包括单行注释和块级注释。单行注释以两个斜杠开头")]),v._v(" "),t("li",[v._v("严格模式：要在整个脚本中启用严格模式，可以在顶部或函数内部的开头添加如下代码： "),t("code",[v._v('"use strict";')])]),v._v(" "),t("li",[v._v("语句：句末分号和代码块")])]),v._v(" "),t("h3",{attrs:{id:"关键字和保留字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关键字和保留字"}},[v._v("#")]),v._v(" 关键字和保留字")]),v._v(" "),t("ul",[t("li",[v._v("关于这部分一般不用记啦，常用的我们肯定不会用，记不住的编辑器也不会通过")])]),v._v(" "),t("h3",{attrs:{id:"变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[v._v("#")]),v._v(" 变量")]),v._v(" "),t("ul",[t("li",[v._v("JS 的变量是松散型变量：意为每个变量仅仅是一个用于保存值的占位符而已，可以保存任何类型的数据")]),v._v(" "),t("li",[v._v("不建议改变变量所保存值的类型，但是这样的操作有效")]),v._v(" "),t("li",[v._v("用 var 操作符定义的变量将成为定义该变量的"),t("strong",[v._v("作用域中的局部变量")]),v._v("。也就是说， 如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁")]),v._v(" "),t("li",[v._v("虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法")])]),v._v(" "),t("h2",{attrs:{id:"二、数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、数据类型"}},[v._v("#")]),v._v(" 二、数据类型")]),v._v(" "),t("h3",{attrs:{id:"typeof-操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typeof-操作符"}},[v._v("#")]),v._v(" typeof 操作符")]),v._v(" "),t("ul",[t("li",[v._v("注意：typeof 是一个操作符而不是函数")]),v._v(" "),t("li",[v._v("typeof 的返回值\n"),t("ul",[t("li",[v._v('"undefined"——如果这个值未定义')]),v._v(" "),t("li",[v._v('"boolean"——如果这个值是布尔值')]),v._v(" "),t("li",[v._v('"string"——如果这个值是字符串')]),v._v(" "),t("li",[v._v('"number"——如果这个值是数值')]),v._v(" "),t("li",[v._v('"object"——如果这个值是对象或 null')]),v._v(" "),t("li",[v._v('"function"——如果这个值是函数。')])])]),v._v(" "),t("li",[v._v("可以写成"),t("code",[v._v("typeof(XXX)")]),v._v("或者"),t("code",[v._v("typeof XXX")])]),v._v(" "),t("li",[v._v("只能准确判断基本类型，不能判断引用类型，引用类型会返回 Object")])]),v._v(" "),t("h3",{attrs:{id:"undefined-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#undefined-类型"}},[v._v("#")]),v._v(" Undefined 类型")]),v._v(" "),t("ul",[t("li",[v._v("Undefined 类型只有一个值，即特殊的 undefined。在"),t("strong",[v._v("使用 var 声明变量但未对其加以初始化时")]),v._v("，这个变量的值就是 undefined")]),v._v(" "),t("li",[v._v("一般而言，不存在需要显式地把一个变量设置为 undefined 值的情况。字面值 undefined 的主要目的是用于比较")]),v._v(" "),t("li",[v._v("对于"),t("strong",[v._v("尚未声明过的变量")]),v._v("，只 能执行一项操作，即使用 typeof 操作符检测其数据类型，会显示 undefined")]),v._v(" "),t("li",[v._v("对未初始化和未声明的变量执行 typeof 操作符都返回了 undefined 值")])]),v._v(" "),t("h3",{attrs:{id:"null-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#null-类型"}},[v._v("#")]),v._v(" Null 类型")]),v._v(" "),t("ul",[t("li",[v._v("Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，"),t("strong",[v._v("null 值表示一个空对象指")]),v._v('针，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因')]),v._v(" "),t("li",[v._v("只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。")]),v._v(" "),t("li",[v._v("实际上，undefined 值是派生自 null 值的，因此 "),t("code",[v._v("alert(null == undefined); //true")])])]),v._v(" "),t("h3",{attrs:{id:"boolean-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#boolean-类型"}},[v._v("#")]),v._v(" Boolean 类型")]),v._v(" "),t("ul",[t("li",[v._v("Boolean 类型是 JS 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。 这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于 0。")]),v._v(" "),t("li",[v._v("区分大小写，True 和 False （以及其他的混合大小写形式）都不是 Boolean 值，只是标识符")]),v._v(" "),t("li",[v._v("可以对任何数据类型的值调用 Boolean()函数，而且总会返回一个 Boolean 值")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[v._v("数据类型")]),v._v(" "),t("th",{staticStyle:{"text-align":"center"}},[v._v("转换为 true 的值")]),v._v(" "),t("th",{staticStyle:{"text-align":"center"}},[v._v("转换为 false 的值")])])]),v._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("Boolean")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("true")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("false")])]),v._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("String")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("任何非空字符串")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v('""（空字符串)')])]),v._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("Number")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("任何非零数字值（包括无穷大）")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("0 和 NaN")])]),v._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("Object")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("任何对象")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("null")])]),v._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("Undefined")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("X")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("undefined")])])])]),v._v(" "),t("h3",{attrs:{id:"number-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#number-类型"}},[v._v("#")]),v._v(" Number 类型")]),v._v(" "),t("ul",[t("li",[v._v("浮点数值\n"),t("ul",[t("li",[v._v("所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字")]),v._v(" "),t("li",[v._v("保存浮点数值需要的内存空间是保存整数值的两倍，所以能转的情况下通常保存为整数")]),v._v(" "),t("li",[v._v("对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。用 e 表示法 表示的数值等于 e 前面的数值乘以 10 的指数次幂"),t("br"),v._v(" "),t("code",[v._v("var floatNum = 3.125e7; // 等于 31250000")])]),v._v(" "),t("li",[v._v("浮点数值的高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数")])])]),v._v(" "),t("li",[v._v("数值范围\n"),t("ul",[t("li",[v._v("最小数 Number.MIN_VALUE 在大多数浏览器中，这个值是 5e-324")]),v._v(" "),t("li",[v._v("最大数 Number.MAX_VALUE 在大多数浏览器中，这个值是 1.7976931348623157e+308")]),v._v(" "),t("li",[v._v("超出 JavaScript 数值范围的值，将被自动转换成特殊的 Infinity 值。-Infinity（负无穷） Infinity（正无穷）")]),v._v(" "),t("li",[v._v("如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算")]),v._v(" "),t("li",[v._v("isFinite(X)函数：可以检测 X 数值是否在最大最小值之间")])])]),v._v(" "),t("li",[v._v("NaN\n"),t("ul",[t("li",[v._v("NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数 未返回数值的情况（这样就不会抛出错误了）")]),v._v(" "),t("li",[v._v("JS 中，任何数值除以 0 会返回 NaN，因此不会影响其他代码的执行")]),v._v(" "),t("li",[v._v("任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN")]),v._v(" "),t("li",[v._v("NaN 与任何值都不相等，包括 NaN 本身")]),v._v(" "),t("li",[v._v("isNaN()函数：isNaN()在接收到一个值之后，会尝试将这个值转换为数值。而任何不能被转换为数值的值都会导致这个函数返回 true。")]),v._v(" "),t("li",[v._v("在基于对象调用 isNaN()函数时，会首先调用对象的 valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString()方法，再测试返回值。")])])]),v._v(" "),t("li",[v._v("数值转换\n"),t("ul",[t("li",[v._v("Number()：可以用于任何数据类型")]),v._v(" "),t("li",[v._v("parseInt()和 parseFloat()：把字符串转换成数值")]),v._v(" "),t("li",[v._v("parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN")]),v._v(" "),t("li",[v._v("parseInt()可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。不指定基数意味着让 parseInt()决定如何解析输入的字符串")]),v._v(" "),t("li",[v._v("parseFloat()也是从第一个字符（位置 0）开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。")]),v._v(" "),t("li",[v._v("parseFloat()只解析十进制，所以不用指定基数，与 parseInt()的第二个区别在于它始终都会忽略前导的零")])])])]),v._v(" "),t("h3",{attrs:{id:"string-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-类型"}},[v._v("#")]),v._v(" String 类型")]),v._v(" "),t("ul",[t("li",[v._v("字符字面量：也叫转义序列，用于表示非打印字符，或者具有其 他用途的字符。")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("字面量")]),v._v(" "),t("th",[v._v("含义")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("\\n")]),v._v(" "),t("td",[v._v("换行")])]),v._v(" "),t("tr",[t("td",[v._v("\\t")]),v._v(" "),t("td",[v._v("制表")])]),v._v(" "),t("tr",[t("td",[v._v("\\b")]),v._v(" "),t("td",[v._v("空格")])]),v._v(" "),t("tr",[t("td",[v._v("\\r")]),v._v(" "),t("td",[v._v("回车")])]),v._v(" "),t("tr",[t("td",[v._v("\\f")]),v._v(" "),t("td",[v._v("进纸")])]),v._v(" "),t("tr",[t("td",[v._v("\\")]),v._v(" "),t("td",[v._v("斜杠")])]),v._v(" "),t("tr",[t("td",[v._v("'")]),v._v(" "),t("td",[v._v("单引号（'），在用单引号表示的符串中使用。例如：'He said,'hey.''")])]),v._v(" "),t("tr",[t("td",[v._v('"')]),v._v(" "),t("td",[v._v('双引号（"），在用双引号表示的符串中使用。例如："He said,"hey.""')])]),v._v(" "),t("tr",[t("td",[v._v("\\xnn")]),v._v(" "),t("td",[v._v('以十六进制代码 nn 表示的一个符（其中 n 为 0 ～ F）。例如，\\x41 表示""')])]),v._v(" "),t("tr",[t("td",[v._v("\\unnnn")]),v._v(" "),t("td",[v._v("以十六进制代码 nnnn 表示的一个 Unicod 字符（其中 n 为 0 ～ F）。例如，\\u03a3 示希腊字符 Σ")])])])]),v._v(" "),t("ul",[t("li",[v._v("字符串特点"),t("br"),v._v("\nJS 字符串是不可变的也就是说，字符串一旦创建，它们的就不能改变。要改变某个变量保存的符串，首先要销毁原来的字符串，然再用另一个包含新值的字符串填充该变")]),v._v(" "),t("li",[v._v("转换为字符串"),t("br"),v._v("\ntoString()方法：数值（可以传递基作为目标进制）、布尔值、对象和字串值适用，但 null 和 undefined 值没有这个方法，分别返回 null 和 undefined")])]),v._v(" "),t("h3",{attrs:{id:"object-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-类型"}},[v._v("#")]),v._v(" Object 类型")]),v._v(" "),t("p",[v._v("对象其实就是一组数据和功能的集合。Object 的每个实例都具有下列属性和方法")]),v._v(" "),t("ul",[t("li",[v._v("constructor：保存着用于创建当前对象的函数。")]),v._v(" "),t("li",[v._v("hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以"),t("strong",[v._v("字符串形式指定")]),v._v("。")]),v._v(" "),t("li",[v._v("isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。")]),v._v(" "),t("li",[v._v("propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。")]),v._v(" "),t("li",[v._v("toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。")]),v._v(" "),t("li",[v._v("toString()：返回对象的字符串表示。")]),v._v(" "),t("li",[v._v("valueOf()：返回对象的"),t("strong",[v._v("字符串、数值或布尔值表示")]),v._v("。通常与 toString()方法的返回值相同。")])]),v._v(" "),t("h2",{attrs:{id:"三、操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、操作符"}},[v._v("#")]),v._v(" 三、操作符")]),v._v(" "),t("h3",{attrs:{id:"一元操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一元操作符"}},[v._v("#")]),v._v(" 一元操作符")]),v._v(" "),t("ul",[t("li",[v._v("只能操作一个值的操作符叫做一元操作符")]),v._v(" "),t("li",[v._v("递增和递减操作符\n"),t("ul",[t("li",[v._v("前置：执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的（变之后再求值）")]),v._v(" "),t("li",[v._v("后置：递增和递减操作是在包含它们的语句被求 值之后才执行的（求值之后再变）")])])]),v._v(" "),t("li",[v._v("一元加和减操作符\n"),t("ul",[t("li",[v._v("一元加操作符放在数值前面，对数值不会产生任何影响")]),v._v(" "),t("li",[v._v("对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。")]),v._v(" "),t("li",[v._v("在将一元减操作符应用于数值时，该值会变成负数（如上面的例子所示）。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，后再将得到的数值转换为负数")])])])]),v._v(" "),t("h3",{attrs:{id:"位操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#位操作符"}},[v._v("#")]),v._v(" 位操作符")]),v._v(" "),t("ul",[t("li",[v._v("位操作符用于在基本的层次上，即按内存表示数值的位来操作数值")]),v._v(" "),t("li",[v._v("对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正 数，1 表示负数。")]),v._v(" "),t("li",[v._v("按位非（NOT） - 按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码 - 按位非操作的本质：操作数的负值减 1。 (例如 25 按位非之后-26)\n"),t("ul",[t("li",[v._v("按位与（AND）\n"),t("ul",[t("li",[v._v("按位与操作符由一个和号字符（&）表示，它有两个操作符数。")]),v._v(" "),t("li",[v._v("按位与操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。")])])]),v._v(" "),t("li",[v._v("按位或（OR）\n"),t("ul",[t("li",[v._v("按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。")]),v._v(" "),t("li",[v._v("按位或操作在有一个位是 1 的情况下就返回 1，而只有在两个位都是 0 的情况下才返回 0。")])])]),v._v(" "),t("li",[v._v("按位异或（XOR）\n"),t("ul",[t("li",[v._v("按位异或操作符由一个插入符号（^）表示，也有两个操作数。")]),v._v(" "),t("li",[v._v("这个操作在两个数值对应位上只有一个 1 时才返回 1，如果对 应的两位都是 1 或都是 0，则返回 0。")])])]),v._v(" "),t("li",[v._v("左移\n"),t("ul",[t("li",[v._v("左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。")])])]),v._v(" "),t("li",[v._v("右移\n"),t("ul",[t("li",[v._v("有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向右移动，但保留符号位（即 正负号标记）。")]),v._v(" "),t("li",[v._v("无符号右移操作符由 3 个大于号（>>>）表示，这个操作符会将数值的所有 32 位都向右移动。对正 数来说，无符号右移的结果与有符号右移相同。")])])])])])]),v._v(" "),t("h3",{attrs:{id:"布尔操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布尔操作符"}},[v._v("#")]),v._v(" 布尔操作符")]),v._v(" "),t("ul",[t("li",[v._v("逻辑非： 逻辑非操作符由一个叹号（！）表示，可以应用于 ECMAScript 中的任何值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再 对其求反。\n"),t("ul",[t("li",[v._v("逻辑与： 逻辑与操作符由两个和号（&&）表示，有两个操作数\n"),t("ul",[t("li",[v._v("如果有一个操作数是 null，则返回 null；")]),v._v(" "),t("li",[v._v("如果有一个操作数是 NaN，则返回 NaN；")]),v._v(" "),t("li",[v._v("如果有一个操作数是 undefined，则返回 undefined。")])])]),v._v(" "),t("li",[v._v("逻辑或 ：逻辑或操作符由两个竖线符号（||）表示，有两个操作数\n"),t("ul",[t("li",[v._v("如果两个操作数是 null，则返回 null；")]),v._v(" "),t("li",[v._v("如果两个操作数是 NaN，则返回 NaN；")]),v._v(" "),t("li",[v._v("如果两个操作数是 undefined，则返回 undefined。")])])])])])]),v._v(" "),t("h3",{attrs:{id:"乘性操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#乘性操作符"}},[v._v("#")]),v._v(" 乘性操作符")]),v._v(" "),t("ul",[t("li",[v._v("乘法：乘法操作符由一个星号（_）表示，用于计算两个数值的乘积。 - 正负乘法法则，另外，乘积超过 JS 数字范围， 则返回 Infinity 或-Infinity； - X _ NaN = NaN； - Infinity _ 0 = NaN； - Infinity _ Infinity = Infinity； - 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数 的符号； - 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。\n"),t("ul",[t("li",[v._v("除法：除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算\n"),t("ul",[t("li",[v._v("特殊情况与乘法类似")])])]),v._v(" "),t("li",[v._v("求模：求模（余数）操作符由一个百分号（%）表示\n"),t("ul",[t("li",[v._v("如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；")]),v._v(" "),t("li",[v._v("如果被除数是有限大的数值而除数是零，则结果是 NaN；")]),v._v(" "),t("li",[v._v("如果是 Infinity 被 Infinity 除，则结果是 NaN；")]),v._v(" "),t("li",[t("strong",[v._v("如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；")])]),v._v(" "),t("li",[v._v("如果被除数是零，则结果是零；")]),v._v(" "),t("li",[v._v("如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。")])])])])])]),v._v(" "),t("h3",{attrs:{id:"加性操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加性操作符"}},[v._v("#")]),v._v(" 加性操作符")]),v._v(" "),t("ul",[t("li",[v._v('加法 - 如果有一个操作数是 NaN，则结果是 NaN； - Infinity + Infinity = Infinity； - -Infinity + -Infinity = -Infinity； - Infinity + -Infinity = NaN； - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接 起来。 - 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值， 然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串"undefined"和"null"。\n'),t("ul",[t("li",[v._v("减法\n"),t("ul",[t("li",[v._v("如果有一个操作数是"),t("strong",[v._v("字符串、布尔值、null 或 undefined")]),v._v("，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果 就是 NaN；")]),v._v(" "),t("li",[v._v("如果有一个操作数是"),t("strong",[v._v("对象")]),v._v("，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到 的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString() 方法并将得到的字符串转换为数值。")])])])])])]),v._v(" "),t("h3",{attrs:{id:"关系操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关系操作符"}},[v._v("#")]),v._v(" 关系操作符")]),v._v(" "),t("ul",[t("li",[v._v("小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个关系操作符用于对两个值进行比 较，返回一个布尔值。\n"),t("ul",[t("li",[v._v("规则\n"),t("ul",[t("li",[v._v("如果两个操作数都是数值，则执行数值比较。")]),v._v(" "),t("li",[v._v("如果两个操作数都是字符串，则比较两个字符串对应的"),t("strong",[v._v("字符编码值")]),v._v("。")]),v._v(" "),t("li",[v._v("如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较.")]),v._v(" "),t("li",[v._v("如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执 行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较")]),v._v(" "),t("li",[v._v("如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。")])])])])])]),v._v(" "),t("h3",{attrs:{id:"相等操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相等操作符"}},[v._v("#")]),v._v(" 相等操作符")]),v._v(" "),t("ul",[t("li",[v._v("相等和不相等 == !=\n"),t("ul",[t("li",[v._v("转换为数值进行比较 - null 和 undefined 是相等的。 - 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。")]),v._v(" "),t("li",[v._v("全等和不全等 === !==\n"),t("ul",[t("li",[v._v("null === undefined //false")])])])])]),v._v(" "),t("li",[v._v("条件操作符\n"),t("ul",[t("li",[v._v("var max = (num1 > num2) ? num1 : num2;")])])]),v._v(" "),t("li",[v._v("赋值操作符\n"),t("ul",[t("li",[v._v("简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量")]),v._v(" "),t("li",[v._v("乘/赋值（*=）；")]),v._v(" "),t("li",[v._v("除/赋值（/=）；")]),v._v(" "),t("li",[v._v("模/赋值（%=）；")]),v._v(" "),t("li",[v._v("加/赋值（+=）；")]),v._v(" "),t("li",[v._v("减/赋值（-=）；")]),v._v(" "),t("li",[v._v("左移/赋值（<<=）；")]),v._v(" "),t("li",[v._v("有符号右移/赋值（>>=）；")]),v._v(" "),t("li",[v._v("无符号右移/赋值（>>>=）。")])])])]),v._v(" "),t("h3",{attrs:{id:"逗号操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逗号操作符"}},[v._v("#")]),v._v(" 逗号操作符")]),v._v(" "),t("ul",[t("li",[v._v("使用逗号操作符可以在一条语句中执行多个操作")])]),v._v(" "),t("h2",{attrs:{id:"四、语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、语句"}},[v._v("#")]),v._v(" 四、语句")]),v._v(" "),t("h3",{attrs:{id:"if-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#if-语句"}},[v._v("#")]),v._v(" if 语句")]),v._v(" "),t("ul",[t("li",[v._v("推荐使用代码块")])]),v._v(" "),t("h3",{attrs:{id:"do-whlie-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#do-whlie-语句"}},[v._v("#")]),v._v(" do-whlie 语句")]),v._v(" "),t("ul",[t("li",[v._v("do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。 换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。")])]),v._v(" "),t("h3",{attrs:{id:"while-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#while-语句"}},[v._v("#")]),v._v(" while 语句")]),v._v(" "),t("ul",[t("li",[v._v("while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。 因此，循环体内的代码有可能永远不会被执行。")])]),v._v(" "),t("h3",{attrs:{id:"for-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-语句"}},[v._v("#")]),v._v(" for 语句")]),v._v(" "),t("ul",[t("li",[v._v("for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代 码的能力。")]),v._v(" "),t("li",[v._v("使用 while 循环做不到的，使用 for 循环同样也做不到。也就是说，for 循环只是把与循环有关 的代码集中在了一个位置。")])]),v._v(" "),t("h3",{attrs:{id:"for-in-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-in-语句"}},[v._v("#")]),v._v(" for-in 语句")]),v._v(" "),t("ul",[t("li",[v._v("for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。")]),v._v(" "),t("li",[v._v("通过 for-in 循环输出的属性名的顺序是不可预测的。 具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。")]),v._v(" "),t("li",[v._v("如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。")])]),v._v(" "),t("h3",{attrs:{id:"label"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#label"}},[v._v("#")]),v._v(" label")]),v._v(" "),t("ul",[t("li",[v._v("使用 label 语句可以在代码中添加标签，以便将来使用。")]),v._v(" "),t("li",[v._v("这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。加标签的语句一般都 要与 for 语句等循环语句配合使用。")])]),v._v(" "),t("h3",{attrs:{id:"break-和-continue-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#break-和-continue-语句"}},[v._v("#")]),v._v(" break 和 continue 语句")]),v._v(" "),t("ul",[t("li",[v._v("break 和 continue 语句用于在循环中精确地控制代码的执行。")]),v._v(" "),t("li",[v._v("break 语句会立即退出循环，强制继续执行循环后面的语句。")]),v._v(" "),t("li",[v._v("continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶 部继续执行。")])]),v._v(" "),t("h3",{attrs:{id:"with-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#with-语句"}},[v._v("#")]),v._v(" with 语句")]),v._v(" "),t("ul",[t("li",[v._v("with 语句的作用是将代码的作用域设置到一个特定的对象中。")]),v._v(" "),t("li",[v._v("定义 with 语句的目的主要是为了简化多次编写同一个对象的工")]),v._v(" "),t("li",[v._v("由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此 在开发大型应用程序时，不建议使用 with 语句。")])]),v._v(" "),t("h3",{attrs:{id:"switch-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#switch-语句"}},[v._v("#")]),v._v(" switch 语句")]),v._v(" "),t("ul",[t("li",[v._v("switch 语句与 if 语句的关系为密切，而且也是在其他语言中普遍使用的一种流控制语句。")]),v._v(" "),t("li",[v._v("break 关键字会导致代码执行流跳出 switch 语句。")]),v._v(" "),t("li",[v._v("如果省略 break 关键字， 就会导致执行完当前 case 后，继续执行下一个 case。")]),v._v(" "),t("li",[v._v("default 关键字则用于在表达式不匹配前 面任何一种情形的时候，执行机动代码（因此，也相当于一个 else 语句）。")]),v._v(" "),t("li",[v._v("可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有 问题。")]),v._v(" "),t("li",[v._v("每个 case 的值不一定是常量，可以是变量，甚至是表达式。")])]),v._v(" "),t("h2",{attrs:{id:"五、函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、函数"}},[v._v("#")]),v._v(" 五、函数")]),v._v(" "),t("p",[v._v("推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如 果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。")]),v._v(" "),t("p",[v._v("严格模式对函数有一些限制：")]),v._v(" "),t("ul",[t("li",[v._v("不能把函数命名为 eval 或 arguments；")]),v._v(" "),t("li",[v._v("不能把参数命名为 eval 或 arguments；")]),v._v(" "),t("li",[v._v("不能出现两个命名参数同名的情况。")]),v._v(" "),t("li",[v._v("如果发生以上情况，就会导致语法错误，代码无法执行。")])]),v._v(" "),t("h3",{attrs:{id:"参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[v._v("#")]),v._v(" 参数")]),v._v(" "),t("ul",[t("li",[v._v("JS 函数不介意传递参数的个数和类型。例如即使定义的是两个参数，但是你也可以传递多个参数或者不传递。原因是 JS 中参数在内部都是以数组表示，函数接收的始终是一个数组，并不关心里面的数值类型及个数。")]),v._v(" "),t("li",[v._v("在函数体内可以通过 arguments 对象来 访问这个参数数组，从而获取传递给函数的每一个参数。")]),v._v(" "),t("li",[v._v("arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访 问它的每一个元素。")]),v._v(" "),t("li",[v._v("通过访问 arguments 对象的 length 属性可以获知有多少个参数传递给了函数。")]),v._v(" "),t("li",[v._v("没有传递值的命名参数将自动被赋予 undefined 值。")])]),v._v(" "),t("h3",{attrs:{id:"没有重载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#没有重载"}},[v._v("#")]),v._v(" 没有重载")]),v._v(" "),t("ul",[t("li",[v._v("如果在 JS 中定义了两个名字相同的函数，则该名字只属于后定义的函数")])]),v._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),t("ul",[t("li",[v._v("JS 中的基本数据类型包括 Undefined、Null、Boolean、Number 和 String。  与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型，Number 类型可 用于表示所有数值。")]),v._v(" "),t("li",[v._v("JS 中也有一种复杂的数据类型，即 Object 类型，该类型是这门语言中所有对象的基 础类型。")]),v._v(" "),t("li",[v._v("严格模式为这门语言中容易出错的地方施加了限制。")]),v._v(" "),t("li",[v._v("JS 提供了很多与 C 及其他类 C 语言中相同的基本操作符，包括算术操作符、布尔操作 符、关系操作符、相等操作符及赋值操作符等。")]),v._v(" "),t("li",[v._v("JS 从其他语言中借鉴了很多流控制语句，例如 if 语句、for 语句和 switch 语句等。")]),v._v(" "),t("li",[v._v("JS 中的函数与其他语言中的函数有诸多不同之处。")]),v._v(" "),t("li",[v._v("无须指定函数的返回值，因为任何 JS 函数都可以在任何时候返回任何值。")]),v._v(" "),t("li",[v._v("实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。")]),v._v(" "),t("li",[v._v("JS 中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式 传递的。")]),v._v(" "),t("li",[v._v("可以向 JS 函数传递任意数量的参数，并且可以通过 arguments 对象来访问这些参数。")]),v._v(" "),t("li",[v._v("由于不存在函数签名的特性，JS 函数不能重载。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);